# 미로 찾기

- 랭크 : 실버 1
- [미로 찾기](https://www.acmicpc.net/problem/2178)
- 그래프 이론
- 그래프 탐색
- 너비 우선 탐색

# 풀이

풀었는데 틀렸던 문제로 되어있어서 없애려고 푼 문제.

알고리즘 문제를 너무 안풀다가 봐서 하나도 기억이 안났다. 기억 나는 부분이 몇가지 있었는데...

```
int x[4] = {1,-1,0,0};
int y[4] = {0,0,1,-1};
```

이런걸 썻던거 말고는 기억이 안났다.

아무튼... BFS 혹은 DFS와 같은 탐색 알고리즘으로 풀 수 있는 문제이다. 미로를 탈출하는 최단 거리에 대해 묻는 문제이다.

사실... 잘 모르겠어서 예전부터 [즐겨보는 블로그](https://blog.naver.com/kks227/220574993422)를 참고했다. (코드는 안보고 풀이만 봄.)

```
0) visited 배열을 모두 false로 초기화한다. success = false로 초기화한다.

1) 시작점 상태를 S라 할 때, visited[S] = true로 하고 큐에 S를 넣는다.

2) 큐에서 맨 앞의 상태를 꺼내 C라고 한다.

3) C가 도착점 상태 E와 같다면 success = true로 하고 6)으로 빠져나간다.

4) C의 각 인접한 상태 N에 대해, visited[N] == false일 경우 visited[N] = true로 하고 큐에 N을 넣는다.

5) 큐가 비어 있다면 6)으로, 아니라면 2)로 돌아간다.

6) 루프 끝. success == false(혹은 visited[E] == false)라면, 도착점은 시작점으로부터 어떤 경로를 통해도 방문할 수 없다.
```
블로그에서 설명한 내요을 일부 발췌했다. 그리고 이 내용을 바탕으로 코딩했다.

정직하게 코딩하면 풀리는 문제라... 여기서 끝...

### 기타

문제 조건에 "각각의 수들은 붙어서 입력으로 주어진다."가 있다. 과거의 나는 문자열로 입력받고 쪼개서 다시 int 배열에 넣어줬는데...

```
scanf("%1d",&maze[i][j]);
```
이번에 검색해보니 위와 같이 손쉽게 입력 받을 수 있다는 것을 알았다.
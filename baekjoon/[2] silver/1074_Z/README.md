# Z

- 랭크 : 실버 1
- [Z](https://www.acmicpc.net/problem/1074)
- 분할 정복
- 재귀

# 풀이

이 문제는 [색종이 만들기](https://www.acmicpc.net/problem/2630)를 풀었던 기억을 참고해서 풀었다.

문제는 배열을 Z 모양으로 탐색을 돌리는데, 특정 좌표가 몇번째 방문에 탐색되는지를 알아내는 문제이다.

|||||
|:---:|:---:|:---:|:---:|
|0|1|4|5|
|2|3|6|7|
|8|9|12|13|
|10|11|14|15|

N이 2일 경우의 예시가 위와 같다. 번호를 매긴 대로 방문 하는데, Z 모양으로 방문읋 하니 이를 구역으로 나눠서 분할 정복을 돌리면 된다.

- 1구역 (왼쪽 위) : 0,1,2,3
- 2구역 (오른쪽 위) : 4,5,6,7
- 3구역 (왼쪽 아래) : 8,9,10,11
- 4구역 (오른쪽 아래) : 12,13,14,15

```c++
else if( c >= x+divider && r >= y+divider )
{
    counter += 3 * divider * divider;
    dc(x+divider, y+divider, divider);
}
```
계산같은 경우에는 위와 같이 했다. 4구역에 해당 좌표가 들어가면, 구역 사이즈와 똑같은 구간을 3번 건너온거니까 그 구간 크기만큼 더해주는 형식으로 계산했다.

문제는 이러한 방식은 가장 작은 Z 까지만 알아낼 수 있고 그 이상은 알아낼 수 없었다.
```c++
int gogo(int x, int y)
{
	if( r == y && c == x )
	{
		return 0;
	}
	else if( r == y && c == x+1 )
	{
		return 1;
	}
	else if( r == y+1 && c == x )
	{
		return 2;
	}
	else if( r == y+1 && c == x+1 )
	{
		return 3;
	}
}
```
그래서 마지막 Z에서 위치를 알아내는건 위와 같이 수동으로 위치를 알아내는 함수를 하나 더 사용하였다. 출력값이 int 범위를 넘어갈 수 있다는 것도 유의해서 코딩하면 문제 풀이 끝.
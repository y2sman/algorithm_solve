# 크리보드

- 랭크 : 실버 1
- [크리보드](https://www.acmicpc.net/problem/11058)
- 다이나믹 프로그래밍

# 풀이

추천받아서 푼 DP 문제이다.

이거 실제로 엑셀에 DP[1]에서 DP[14]까지 적으면서 풀었다. 머리가 안좋아서... 손으로라도 해야한다.

최초에 계산했을때는 틀렸었다. 문제 힌트에 적혀있는 내용을 잘못 이해해서 그렇다.

```
N = 3인 경우에 A, A, A를 눌러 A 3개를 출력할 수 있다.

N = 7인 경우에는 A, A, A, Ctrl-A, Ctrl-C, Ctrl-V, Ctrl-V를 눌러 9개를 출력할 수 있다.

N = 11인 경우에는 A, A, A, Ctrl-A, Ctrl-C, Ctrl-V, Ctrl-V, Ctrl-A, Ctrl-C, Ctrl-V, Ctrl-V 를 눌러 27개를 출력할 수 있다.
```
(여기서는 Ctrl-A, Ctrl-C, Ctrl-V, Ctrl-V를 ACVV, "A,A,A"를 갯수에 맞춰 X3로 지칭하겠다.)

문제 힌트에서 ACVV를 기준으로 설명하길래, 당연히 이게 최고 효율이라고 생각했다. 그래서 ACVV를 한 세트로 X6까지 계산했다.

그래서 틀렸다. 틀리고나서 곰곰히 생각해보니 ACV도, ACVVV가 최대 효율일 수도 있을 것 같아 다시 계산했다.

|COUNT|N|Lv1||COUNT|Lv2||COUNT|Lv3||COUNT|Lv4||COUNT|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|DP[1]|A||||||||||||
|2|DP[2]|AA||||||||||||
|3|DP[3]|AAA||||||||||||
|4|DP[4]|AAAA||||||||||||
|5|DP[5]|AAAAA||||||||||||
|6|DP[6]|AAAAAA||||||||||||
|9|DP[7]|DP[3]|X2|||||||||||
|12|DP[8]|DP[4]|X2|12|DP[3]|X3|12|||||||
|16|DP[9]|DP[5]|X2|15|DP[4]|X3|16|DP[3]|X4|15||||
|20|DP[10]|DP[6]|X2|18|DP[5]|X3|20|DP[4]|X4|20|DP[3]|X5|18|
|27|DP[11]|DP[7]|X2|27||||||||||
|36|DP[12]|DP[8]|X2|36|DP[7]|X3|36|||||||
|48|DP[13]|DP[9]|X2|48|DP[8]|X3|48|DP[7]|X4|45||||
|64|DP[14]|DP[10]|X2|60|DP[9]|X3|64|DP[8]|X4|60|DP[7]|X5|54|

(이 표 틀렸을 수도 있다. 머리가 돌아가서 계산하는거 확인용으로 여러번 고쳐서... 수식만 얻고 숫자는 안고쳤다. 어차피 코딩하면 나오니까.)

위의 표 같이 계산하고 나니, 일단 DP[9]에서 부터 기존과 다르다는 것을 확인했다. 

그래서 코드를 수정했다.

```cpp
dp[i] = dp[i-4] * 3;
```
와 같이 단순한 점화식? 그냥 계산식에서

```cpp
dp[i] = max({ dp[i-1] + 1, dp[i-3] * 2, dp[i-4] * 3, dp[i-5] * 4, dp[i-6] * 5, dp[i-7] * 6 });
```
로 수정했다.

dp[i-3]에서 dp[i-7]까지는 ACV에서 ACVVVVV까지의 가능성을 따져본 것이고, dp[i-1]에서 +1을 한 것은 표에는 그리지 않았는데 단순이 A를 눌렀을 가능성을 계산한 것이다. (A를 눌렀어도 +1이 되기 때문)

이렇게 넣고 max로 이 중에서 최대 값을 뽑아서 dp[i]에 넣었다. 이번에도 느꼈지만 역시 문제를 잘 읽는 것이 중요하다.

### 기타

사실 max가 안됬었다. 

[max의 cppreference](https://en.cppreference.com/w/cpp/algorithm/max)

gdb에서 안된다고 오류만 뿜길래 왜지...? 라고 했더니... 내 컴파일러 버전이 너무 낮아서 그랬다. 귀찮아서 미뤘더니... 업그레이드좀 해야겠다.

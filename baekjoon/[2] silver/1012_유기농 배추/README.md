# 유기농 배추

- 랭크 : 실버 2
- [유기농 배추](https://www.acmicpc.net/problem/1012)
- 그래프 이론
- 그래프 탐색
- 너비 우선 탐색
- 깊이 우선 탐색

# 풀이

이전에 틀렸던 문제 다시 푸는 문제.

[미로 찾기](https://www.acmicpc.net/problem/2178)에서 배웠던 내용을 그대로 써먹었다.

|||||||||||
:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:
1|1|0|0|0|0|0|0|0|0
0|1|0|0|0|0|0|0|0|0
0|0|0|0|1|0|0|0|0|0
0|0|0|0|1|0|0|0|0|0
0|0|1|1|0|0|0|1|1|1
0|0|0|0|1|0|0|1|1|1

문제는 위와 같이 배추밭이 존재할때 뭉쳐진 배추의 갯수를 구하는 문제이다. 미로찾기에서는 최단거리를 구하는 문제였지만, 여기서는 조금 다르다.

기본적으로 미로찾기에서 사용한 BFS를 조금 고쳐서 사용하기로 했다. 탐색 알고리즘만 돌리고, 최단거리를 구하기 위해 추가한 부분을 뺏다.

묶음의 갯수를 구하는 방법은 아래와 같이 했다.
```c++
void gogo()
{
    for(int i=0;i<N;i++)
    {
        for(int j=0;j<M;j++)
        {
            if(visited[i][j] == 0 && farm[i][j] == 1)
            {
                bfs(i, j);
                counter++;
            }
        }
    }
}
```
아직 방문하지 않았고, 배추가 현재 위치하고 있는 좌표라면 BFS를 돌려서 visited가 방문 한 것으로 바뀌게 하고 묶음 갯수를 더해주는 방법으로 했다. 이런식이면 묶음마다 BFS가 1번씩만 돌아가서 빠르게 배추 묶음 갯수를 셀 수 있다.
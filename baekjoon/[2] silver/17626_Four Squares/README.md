# Four Squares

- 랭크 : 실버 5
- [Four Squares](https://www.acmicpc.net/problem/17626)
- 다이나믹 프로그래밍
- 브루트포스 알고리즘

# 풀이

라그랑주에 대한 내용이 문제 설명으로 나온다. 나같은 수포자는 바로 [위키피디아](https://ko.wikipedia.org/wiki/%EB%9D%BC%EA%B7%B8%EB%9E%91%EC%A3%BC_%EB%84%A4_%EC%A0%9C%EA%B3%B1%EC%88%98_%EC%A0%95%EB%A6%AC)를 열었다.

결론은 모든 숫자는 음이 아닌 정수 4개의 제곱 모양으로 표현할 수 있다는 것이다. (0도 포함~!) 음... 이 식이 무슨 도움이 될까 증명까지 읽어봤는데, 역시 수포자라 이런 방법으로는 못풀겠다. 깔끔하게 그리디는 포기. 그럼 다음은 무엇이냐? DP로 도전했다.

|DP||
|---|---|
|1|1|
|2|1+1|
|3|1+1+1|
|4|2|
|5|2+1|
|6|2+1+1|
|7|2+1+1+1|
|8|2+2|
|9|3|
|10|3+1|
|11|3+1+1|
|12|3+1+1+1|
|13|3+2|
|14|3+2+1|
|22|4+2+2+1|
|23|3+3+2+1|
|24|4+2+2+1|


예시로 그린 DP 표이다. 편의상 제곱 표시는 생략했다. 위와 같은 방법으로 계산하면 된다. 보면 대충 일방향적으로 가는데, 23은 앞뒤와 다르다. 예상한대로 증가하려면 "4+2+2+1+1" 이어야하는데, 이렇게되면 5개로 표현하는거라 정답에서 옳지않다.

이 문제는 그럼 어떻게 푸는가? 결국은 이전의 계산 결과를 제곱수들끼리 비교해야한다.
```cpp
dp[23] = dp[4] + dp[19] //2의 제곱
dp[23] = dp[9] + dp[14] //3의 제곱
dp[23] = dp[16] + dp[7] //4의 제곱
```
23을 기준으로 표현하면 위와 같이 표현할 수 있다. 이제 구현을 하면 되는데, 나같은 경우에는 제곱수(25,36 등등)은 따로 판별해서 그 경우에는 1을 넣어주는 식으로 처리했다.
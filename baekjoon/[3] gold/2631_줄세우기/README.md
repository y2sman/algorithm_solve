# 줄세우기

- 랭크 : 골드 5
- [줄세우기](https://www.acmicpc.net/problem/2631)
- 다이나믹 프로그래밍

# 풀이

이리저리 고민하다가... 이건것 같아서 했는데 이거였다. 일단 줄을 세울때 옮기는 수를 유심히 보았다.

||||||||
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|3|7|5|2|6|1|4|
|X|O|X|O|X|O|O|

예제를 가져왔다. 예제에서 옮긴 숫자들을 O로 표시하고, 옮기지 않은 숫자들을 X로 표시했다. 그럼 정렬을 할 때, 이미 정렬이 되어 있는 숫자들은 옮길 필요가 없다는 것을 알 수 있다.

||||||||
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|2|7|3|5|1|6|4|
|X|O|X|X|O|X|O|

임의로 만들었을 때도, 최소로 옮기려면 이미 정렬되어 있는 숫자들을 찾으면 된다.

하지만 여기서도 최대한 길-게 이어지는 정렬되는 숫자들을 찾아야한다. 그럼 이 이어지는 숫자를 어떻게 구할까?

구글에 "배열 부분 수열"을 검색했더니 ["알고리즘 - 최장 증가 부분 수열(LIS) 알고리즘"](https://chanhuiseok.github.io/posts/algo-49/)이런 게시글을 확인할 수 있었다.

```
예를 들어, { 6, 2, 5, 1, 7, 4, 8, 3} 이라는 배열이 있을 경우, LIS는 { 2, 5, 7, 8 } 이 됩니다.
{ 2, 5 }, { 2, 7 } 등 증가하는 부분 수열은 많지만 그 중에서 가장 긴 것이 { 2, 5, 7, 8 } 입니다.
```

예시를 확인해보니 지금 내가 딱 구하고자 하는 것과 똑같은 알고리즘이었다.

```
주어진 배열에서 인덱스를 한 칸씩(k+=1) 늘려가면서 확인합니다. 그리고 내부 반복문으로 k보다 작은 인덱스들을 하나씩 살펴 보면서 arr[i] < arr[k]인 것이 있을 경우, length[k] 를 업데이트합니다.

업데이트 하는 기준은,

- (1) i번째 인덱스에서 끝나는 최장 증가 부분 수열의 마지막에 arr[k]를 추가했을 때의 LIS 길이와
- (2) 추가하지 않고 기존의 length[k] 값
- 둘 중에 더 큰 값으로 length[k] 값을 업데이트합니다.

출처 : "알고리즘 - 최장 증가 부분 수열(LIS) 알고리즘" (https://chanhuiseok.github.io/posts/algo-49/)
```

실제로 알고리즘 설명을 읽어보면, 배열에서 하나씩 확인해가며 가장 긴 수열의 길이를 업데이트 해가는 방식이었다.

해당 알고리즘을 가져와서 계산을 한 값은 아까 설명했던 대로 말하면 움직이지 않아도 되는 X에 해당하는 최댓값을 알려주는 것이므로, N에서 이 값을 빼서 출력하면 정답이다.